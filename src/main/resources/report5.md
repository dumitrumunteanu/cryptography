# Lab 5

### Course: Cryptography & Security
### Author: Munteanu Dumitru

----

In this laboratory work I defined an authentication system that prompts a user to enter their username and password, and then their 2-factor authentication (2FA) code. If the provided username and password match a user in a pre-defined list of users, and the provided 2FA code is valid, the user is granted access and can then choose to encrypt a message using one of three different ciphers: the Caesar cipher, the Caesar permutation cipher, or the Vigenere cipher. The user's access to each cipher is determined by the ciphers field of their User object, which is a string containing the numbers "1", "2", and/or "3" corresponding to the available ciphers.

Here is a more in-depth explanation...

First I defined the User data class:
```kotlin
data class User(val username: String, val passwordHash: String, val ciphers: String)
```
This data class has three fields:
- username: a string representing the username of the user
- passwordHash: a string representing the hash value of the user's password, as generated by the hashPassword function
- ciphers: a string containing the numbers "1", "2", and/or "3" indicating which ciphers the user has access to

I defined a hashPassword function which will be used to hash the user's password:
```kotlin
fun hashPassword(password: String): String {
    val bytes = password.toByteArray()
    val md = MessageDigest.getInstance("SHA-256")
    val digest = md.digest(bytes)
    return digest.fold("", { str, it -> str + "%02x".format(it) })
}
```
This function takes in a password as a string and returns its hash value using the SHA-256 algorithm. It does this by:
- Converting the password string to a byte array using the toByteArray method
- Creating a message digest object using the MessageDigest class and the getInstance method, and specifying the SHA-256 algorithm
- Hashing the byte array using the message digest object's digest method
- Formatting the hash value as a string by iterating through the byte array and adding each byte as a two-digit hexadecimal string to a result string

The validateTwoFactorAuthCode function takes in a username and a 2FA code as strings, and returns true if the provided code is valid for the user, or false otherwise.
```kotlin
fun validateTwoFactorAuthCode(username: String, code: String): Boolean {
    return code == getTwoFactorAuthKey(username)
}
```
In my implementation, the 2FA code is considered valid if it matches the key returned by the getTwoFactorAuthKey function which takes in a username as a string and returns a hardcoded 2FA key for the user. If the provided username does not match any of the hardcoded users, it returns an empty string..
```kotlin
fun getTwoFactorAuthKey(username: String): String {
    // For the sake of this example, we'll just return a hardcoded key for each user
    return when (username) {
        "Alice" -> "1234567890"
        "Bob" -> "0987654321"
        "Charlie" -> "abcdefghij"
        else -> ""
    }
}
```

The `encryptUserMessage(user: User, message: String)` function takes in a User object and a message string, and prompts the user to choose which cipher they want to use to encrypt the message. It then checks if the user has access to the chosen cipher by checking if the ciphers field of the User object contains the number corresponding to the chosen cipher. If the user has access to the cipher, the function encrypts the message using the chosen cipher. If the user does not have access to the cipher, it prints an error message.

Inside the function I create three cipher objects: a CaesarCipher object with a shift of 15, a CaesarPermutationCipher object with a secret key of "secret" and a shift of 4, and a VigenereCipher object with a key of "verySECRETkey". It then prompts the user to choose a cipher and reads their input. If the user's choice is "1", it encrypts the message using the CaesarCipher object. If the user's choice is "2", it encrypts the message using the CaesarPermutationCipher object. If the user's choice is "3", it encrypts the message using the VigenereCipher object.

The flow of hte main program is the following:
1. Create a hashmap called users to store the pre-defined list of users.
    ```kotlin
    val users = HashMap<String, User>()
    ```
2. Add three users to the users hashmap with the names "Alice", "Bob", and "Charlie", and sets their respective passwordHash field to the hash value of their password, and their ciphers field to a string indicating which ciphers they have access to.
    ```kotlin
    sers["Alice"] = User("Alice", hashPassword("password1"), "1")
    users["Bob"] = User("Bob", hashPassword("password2"), "12")
    users["Charlie"] = User("Charlie", hashPassword("password3"), "3")
    ```
3. Prompts the user to enter their username and password, and reads their input. If the provided username and password match a user in the users hashmap, prompts the user to enter their 2FA code and reads their input.
    ```kotlin
    if (username in users && users[username]!!.passwordHash == hashPassword(password)) {
        // Prompt the user to enter their 2FA code
        print("Enter your 2FA code: ")
        val twoFactorAuthCode = readLine()!!
            ...
    ```
4. If the provided 2FA code is valid for the user, the user can enter a message to be encrypted. 
    ```kotlin
    if (validateTwoFactorAuthCode(username, twoFactorAuthCode)) {
        println("2FA successful. Welcome, $username!")
        while (true) {
            println("What would you like to encrypt?")
            val messageToEncrypt = readLine()!!
            encryptUserMessage(users[username]!!, messageToEncrypt)
        }
    }
    ```
5. The user is prompted to choose a cipher and the message is encrypted using the chosen cipher if the user has access to it.
    ```kotlin
    println("Which cipher would you like to use (1 - Caesar; 2 - Caesar with permutation; 3 - Vigenere)")
    val choice = readLine()!!
    
    // check if the user has access to the cipher
    if (user.ciphers.contains(choice[0])) {
        when (choice) {
            "1" -> {
                encryptMessageWithCipher(message, caesarCipher)
            }
            "2" -> {
                encryptMessageWithCipher(message, caesarPermutationCipher)
            }
            "3" -> {
                encryptMessageWithCipher(message, vigenere)
            }
        }
    }
    ```
   

Note: If the provided username and password do not match a user in the users hashmap, or if the provided 2FA code is not valid for the user, the program prints an error message and exits.

